package scalydomain.core

import scala.util.Random

class MarkovChainGenerator(val db: ModelDbReader) {
	val n = db.modelInfo.n
	val Prefix = "^" * n
	val Suffix = "$" * n

	val rand = new Random()

	def generate(maxLength:Long = -1, withPrefix:String = ""): String = {
		var next: String = null

		do {
			//Drop the prefix ngram and the suffix ngram from the generated text
			next = generateNext(Prefix + withPrefix).drop(n).reverse.drop(n).reverse
		} while (maxLength != -1 && next.length() > maxLength)

		next
	}

	def generateNext(soFar: String): String = {
		//Start with the pure prefix ngram, and keep iterating until we get to the
		//end.  If there is a prefix, use that as the initial ngram
		val ngram = soFar takeRight n

		db.lookupNgram(ngram) match {
			case Some(entry) => {
				generateNext(soFar + chooseNextSymbol(entry, rand))
			}

			//The only ngram that won't ever have an entry is the suffix ngram, so
			//if we can't choose a next symbol it means we've come to the end
			case None => {
				soFar
			}
		}
	}

	// Given a string generated from this model, decomposes the string into its constituent
	// n-grams and returns a collection containing the probabilities of each of those ngrams being
	// generated, given the prior ngram, plus a final probability that the string would end where it did.
	// Probabilities are 0.0 to 1.0.  If a string is passed
	// which cannot be generated by this model, it will be processed anyway, and characters in the sequence which
	// could not possibly be generated by the model will yield p of 0
	def computeCharacterProbabilities(result: String): Iterator[Double] = {
		//Decompose the string into a series of substrings formed by a sliding window, each substring consisting
		//of an ngram and the character immediately following
		//
		//Note the entire Suffix isn't needed here, since we know that as soon as the '$' character is generated that will trigger
		//the end of the sequence.
		val segments = (Prefix + result + "$").sliding(n+1)

		//Split each segment into the first n characters (the ngram), and the last one (the following symbol)
		val ngramSymPairs = for (seg <- segments) yield { (seg take n, seg drop n) }

		//replace the string ngrams with the corresponding NgramEntry records in the database
		val entries = for ((ngram, nextSym) <- ngramSymPairs) yield { (db.lookupNgram(ngram), nextSym) }

		//look up the occurrences count for the next symbol in the entry hash table, which we need to compute a probability
		val nextSymbolCounts = for (tuple <- entries) yield {
			tuple match {
				case (Some(entry), nextSym) => (Some(entry), entry.nextSymbols.get(nextSym))
				case _ => (None, None)
			}
		}

		//Finally, compute the probabilities, returning 0.0 if the entry or the next symbol aren't found
		val probabilities = for (tuple <- nextSymbolCounts) yield {
			tuple match {
				case (Some(entry), Some(countNextSymbol)) => countNextSymbol.toDouble / entry.allNextSymbolsSum.toDouble
				case _ => 0.0
			}
		}

		probabilities
	}

	// Given a string generated from this model, breaks it down into ngrams and provides the probability of each of those
	// ngrams appearing in the training corpus.  Note that unlike computeCharacterProbabilities, which returns the conditional
	// probablities of each character given the ngram preceeding it, these probablities are not conditional, they simply indicate
	// how often each ngram appeared in the corpus.  Make of that what you will
	//
	// because this computes ngram probabilities, the result will consist of result.length-n probabilities
	def computeNgramProbabilities(result: String): Iterator[Double] = {
		val ngrams = result.sliding(n)

		//replace the string ngrams with the corresponding NgramEntry records in the database
		val entries = ngrams.map(db.lookupNgram(_))

		entries.map {
			case Some(entry) => entry.p
			case None => 0.0
		}
	}

	def chooseNextSymbol(entry: NgramEntry, rand: Random) = {
		var sum = 0l
		var randomIndex: Long = 0

		do {
			randomIndex = rand.nextLong % entry.allNextSymbolsSum
		} while (randomIndex < 0)

		//Create a collection of the next symbols with the occurrence count replaced by the
		//running total of all counts of all next symbols up to this point
		val nextSymbols = entry.nextSymbols.toIterable
			.scanLeft(("", 0l)) { (runningTotal, nextSymbolPair) =>
				val (_, sum) = runningTotal
				val (symbol, count) = nextSymbolPair

				(symbol, sum + count)
			}
			.tail //The first element from scanLeft is the initial state, but that's just to start the sum at 0, we don't want to use it as a next symbol

		//Skip all next symbols whose running total is less than the randomly selected index.
		//The first symbol after those dropped ones is the one we randomly pick
		nextSymbols.dropWhile { pair => pair._2 <= randomIndex }.map(_._1).headOption match {
			case Some(sym) => sym
			case None => throw new Exception(s"failed to nominate a next symbol for ngram $entry")
		}
	}
}